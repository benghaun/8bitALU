module testSM ( //module containing state machine for automatic testing of the ALU
    input clk,  // clock
    input rst,  // reset
    input result[8], //input of result for checking
    output alufn[6],//outputs of ALUFN, A and B which will be input into the ALU for testing
    output a[8],
    output b[8],
    input pause, //check if pause button is pressed
    output error //output to indicate if there the error state is reached
  ) {
.clk(clk){
  .rst(rst){
    dff counter[27]; //counter to keep track of time
    fsm state = {ADD,ADDV,ADDZ,SUB,SUBZ,CMPEQT,CMPEQF,CMPLTT,CMPLTF,CMPLET,CMPLEF,AND,OR,XOR,A,SHL,SHR,SRA,ERROR}; //different states to test different functions of ALU
    }
  }
  always {
    alufn = 6b000000;
    a = 8h00;
    b = 8h00;
    error = 0;
    if (!pause){//increase counter by 1 every clock cycle if pause button isn't pressed
      counter.d = counter.q+1; 
    }
    
    case (state.q){
      state.ADD: //state for testing addition
        alufn = 6b000000;
        a = 8h1E;
        b = 8h37;
        if (counter.q[26]==1){ //MSB of counter is 1, 2^27 clock cycles (approx 2.7s) has passed
          if (result==8h55){ //change state to next state if result is correct
          state.d = state.ADDV;
          counter.d = 27h0000000; //reset counter to 0
          }
          else{ //go to error state if result is wrong
          state.d = state.ERROR;
        }
        }
      
      state.ADDV: //state for testing addition with overflow
        alufn = 6b000000;
        a = 8hF1;
        b = 8hEE;
        if (counter.q[26]==1){
          if (result==8hDF){
            state.d = state.ADDZ;
            counter.d = 27h0000000;
            }  
          else{
            state.d = state.ERROR;
            }
        }
        
      state.ADDZ: //state for testing addition of two zeroes
        alufn = 6b000000;
        a = 8h00;
        b = 8h00;
        if (counter.q[26]==1){
          if (result==8h00){
            state.d = state.SUB;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
        
      state.SUB: //state for testing subtraction
        alufn = 6b000001;
        a = 8h55;
        b = 8h1E;
        if (counter.q[26]==1){
          if (result==8h37){
            state.d = state.SUBZ;
            counter.d = 27h0000000;
            }  
          else{
            state.d = state.ERROR;
            }
        }
        
      state.SUBZ: //state for testing subtraction of two zeroes
        alufn = 6b000001;
        a = 8h00;
        b = 8h00;
        if (counter.q[26]==1){
          if (result==8h00){
            state.d = state.CMPEQT;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
      
      state.CMPEQT: //state for testing CMPEQ (true case)
        alufn = 6b110011;
        a = 8hE0;
        b = 8hE0;
        if (counter.q[26]==1){
          if (result == 8h01){
            state.d = state.CMPEQF;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
        
        
      state.CMPEQF: //false case for CMPEQ
        alufn = 6b110011;
        a = 8hFE;
        b = 8hE1;
        if (counter.q[26]==1){
          if (result == 8h00){
            state.d = state.CMPLTT;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
        
      state.CMPLTT: //state for testing CMPLT (true case)
        alufn = 6b110101;
        a = 8h1E;
        b = 8h55;
        if (counter.q[26]==1){
          if (result == 8h01){
            state.d = state.CMPLTF;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
       
      state.CMPLTF: //false case for CMPLT
        alufn = 6b110101;
        a = 8hDE;
        b = 8hAD;
        if (counter.q[26]==1){
          if (result == 8h00){
            state.d = state.CMPLET;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
        
      state.CMPLET: //state for testing CMPLE (true case)
        alufn = 6b110111;
        a = 8hC0;
        b = 8hC0;
        if (counter.q[26]==1){
          if (result == 8h01){
            state.d = state.CMPLEF;
            counter.d = 27h0000000;
          }
          else{
            state.d = state.ERROR;
          }
        }
        
      state.CMPLEF: //false case for CMPLE
        alufn = 6b110111;
        a = 8hFE;
        b = 8hED;
        if (counter.q[26]==1){
          if (result == 8h00){
              state.d = state.AND;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
    
      state.AND: //state for testing AND
        alufn = 6b011000;
        a=8b10010110;
        b=8b00110101;
        if (counter.q[26]==1){
          if (result == 8b00010100){
              state.d = state.OR;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.OR: //state for testing OR
        alufn = 6b011110;
        a = 8b10110010;
        b = 8b00110100;
        if (counter.q[26]==1){
          if (result == 8b10110110){
              state.d = state.XOR;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.XOR: //state for testing XOR
        alufn = 6b010110;
        a = 8b11010110;
        b = 8b01100101;
        if (counter.q[26]==1){
          if (result == 8b10110011){
              state.d = state.A;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.A: //state for testing A
        alufn = 6b011010;
        a = 8b01100110;
        b = 8b11011100;
        if (counter.q[26]==1){
          if (result == 8b01100110){
              state.d = state.SHL;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.SHL: //state for testing left shift
        alufn = 6b100000;
        a = 8h1E;
        b = 8hff; 
        if (counter.q[26]==1){
          if (result == 8h00){
              state.d = state.SHR;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.SHR: //state for testing right shift
        alufn = 6b100001;
        a = 8hFA;
        b = 8h11; 
        if (counter.q[26]==1){
          if (result == 8h7d){
              state.d = state.SRA;
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.SRA: //state for testing arithmetic right shift
        alufn = 6b100011;
        a = 8hF0;
        b = 8h0D;
        if (counter.q[26]==1){
          if (result == 8hFF){
              state.d = state.ADD; //this is the last state, go back to first state if successful
              counter.d = 27h0000000;
            }
            else{
              state.d = state.ERROR;
          }
        }
        
      state.ERROR: //error state
        error = 1; //indicate that error state has been reached
        
        
        
      
        
      
  
}
}
}